// Autogenerated from Pigeon (v9.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return (value as Any) as! T?
}

/// Generated class from Pigeon that represents data sent in messages.
struct ViewMessage {
  var viewId: Int64

  static func fromList(_ list: [Any]) -> ViewMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)

    return ViewMessage(
      viewId: viewId
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LoadMessage {
  var viewId: Int64
  var url: String

  static func fromList(_ list: [Any]) -> LoadMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let url = list[1] as! String

    return LoadMessage(
      viewId: viewId,
      url: url
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      url,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct AutoQualityModeMessage {
  var viewId: Int64
  var autoQualityMode: Bool? = nil

  static func fromList(_ list: [Any]) -> AutoQualityModeMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let autoQualityMode: Bool? = nilOrValue(list[1])

    return AutoQualityModeMessage(
      viewId: viewId,
      autoQualityMode: autoQualityMode
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      autoQualityMode,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct LoopingMessage {
  var viewId: Int64
  var looping: Bool? = nil

  static func fromList(_ list: [Any]) -> LoopingMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let looping: Bool? = nilOrValue(list[1])

    return LoopingMessage(
      viewId: viewId,
      looping: looping
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      looping,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct MutedMessage {
  var viewId: Int64
  var muted: Bool? = nil

  static func fromList(_ list: [Any]) -> MutedMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let muted: Bool? = nilOrValue(list[1])

    return MutedMessage(
      viewId: viewId,
      muted: muted
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      muted,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct FQualityMessage {
  var viewId: Int64
  var quality: FQuality? = nil

  static func fromList(_ list: [Any]) -> FQualityMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    var quality: FQuality? = nil
    if let qualityList = list[1] as! [Any]? {
      quality = FQuality.fromList(qualityList)
    }

    return FQualityMessage(
      viewId: viewId,
      quality: quality
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      quality?.toList(),
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlaybackRateMessage {
  var viewId: Int64
  var playbackRate: Double? = nil

  static func fromList(_ list: [Any]) -> PlaybackRateMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let playbackRate: Double? = nilOrValue(list[1])

    return PlaybackRateMessage(
      viewId: viewId,
      playbackRate: playbackRate
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      playbackRate,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct SeekMessage {
  var viewId: Int64
  var seconds: Double

  static func fromList(_ list: [Any]) -> SeekMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let seconds = list[1] as! Double

    return SeekMessage(
      viewId: viewId,
      seconds: seconds
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      seconds,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct VolumeMessage {
  var viewId: Int64
  var volume: Double? = nil

  static func fromList(_ list: [Any]) -> VolumeMessage? {
    let viewId = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let volume: Double? = nilOrValue(list[1])

    return VolumeMessage(
      viewId: viewId,
      volume: volume
    )
  }
  func toList() -> [Any?] {
    return [
      viewId,
      volume,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct FQuality {
  var name: String
  var height: Int64
  var width: Int64

  static func fromList(_ list: [Any]) -> FQuality? {
    let name = list[0] as! String
    let height = list[1] is Int64 ? list[1] as! Int64 : Int64(list[1] as! Int32)
    let width = list[2] is Int64 ? list[2] as! Int64 : Int64(list[2] as! Int32)

    return FQuality(
      name: name,
      height: height,
      width: width
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      height,
      width,
    ]
  }
}
private class IvsPlayerApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return AutoQualityModeMessage.fromList(self.readValue() as! [Any])
      case 129:
        return FQuality.fromList(self.readValue() as! [Any])
      case 130:
        return FQualityMessage.fromList(self.readValue() as! [Any])
      case 131:
        return LoadMessage.fromList(self.readValue() as! [Any])
      case 132:
        return LoopingMessage.fromList(self.readValue() as! [Any])
      case 133:
        return MutedMessage.fromList(self.readValue() as! [Any])
      case 134:
        return PlaybackRateMessage.fromList(self.readValue() as! [Any])
      case 135:
        return SeekMessage.fromList(self.readValue() as! [Any])
      case 136:
        return ViewMessage.fromList(self.readValue() as! [Any])
      case 137:
        return VolumeMessage.fromList(self.readValue() as! [Any])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class IvsPlayerApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? AutoQualityModeMessage {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? FQuality {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? FQualityMessage {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? LoadMessage {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? LoopingMessage {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? MutedMessage {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? PlaybackRateMessage {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? SeekMessage {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? ViewMessage {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? VolumeMessage {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class IvsPlayerApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return IvsPlayerApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return IvsPlayerApiCodecWriter(data: data)
  }
}

class IvsPlayerApiCodec: FlutterStandardMessageCodec {
  static let shared = IvsPlayerApiCodec(readerWriter: IvsPlayerApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol IvsPlayerApi {
  func autoQualityMode(mode: AutoQualityModeMessage) throws -> Bool
  func looping(loopingMessage: LoopingMessage) throws -> Bool
  func mute(mutedMessage: MutedMessage) throws -> Bool
  func playbackRate(playbackRateMessage: PlaybackRateMessage) throws -> Double
  func volume(volumeMessage: VolumeMessage) throws -> Double
  func videoDuration(viewMessage: ViewMessage) throws -> Double
  func playbackPosition(viewMessage: ViewMessage) throws -> Double
  func qualities(viewMessage: ViewMessage) throws -> [FQuality]
  func quality(qualityMessage: FQualityMessage) throws -> FQuality
  func create() throws -> Int64?
  func pause(viewMessage: ViewMessage) throws
  func load(loadMessage: LoadMessage) throws
  func play(viewMessage: ViewMessage) throws
  func seekTo(seekMessage: SeekMessage) throws
  func dispose(viewMessage: ViewMessage) throws
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class IvsPlayerApiSetup {
  /// The codec used by IvsPlayerApi.
  static var codec: FlutterStandardMessageCodec { IvsPlayerApiCodec.shared }
  /// Sets up an instance of `IvsPlayerApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: IvsPlayerApi?) {
    let autoQualityModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.autoQualityMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      autoQualityModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let modeArg = args[0] as! AutoQualityModeMessage
        do {
          let result = try api.autoQualityMode(mode: modeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      autoQualityModeChannel.setMessageHandler(nil)
    }
    let loopingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.looping", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loopingChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let loopingMessageArg = args[0] as! LoopingMessage
        do {
          let result = try api.looping(loopingMessage: loopingMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loopingChannel.setMessageHandler(nil)
    }
    let muteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.mute", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      muteChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let mutedMessageArg = args[0] as! MutedMessage
        do {
          let result = try api.mute(mutedMessage: mutedMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      muteChannel.setMessageHandler(nil)
    }
    let playbackRateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.playbackRate", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playbackRateChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let playbackRateMessageArg = args[0] as! PlaybackRateMessage
        do {
          let result = try api.playbackRate(playbackRateMessage: playbackRateMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playbackRateChannel.setMessageHandler(nil)
    }
    let volumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.volume", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      volumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let volumeMessageArg = args[0] as! VolumeMessage
        do {
          let result = try api.volume(volumeMessage: volumeMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      volumeChannel.setMessageHandler(nil)
    }
    let videoDurationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.videoDuration", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      videoDurationChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let viewMessageArg = args[0] as! ViewMessage
        do {
          let result = try api.videoDuration(viewMessage: viewMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      videoDurationChannel.setMessageHandler(nil)
    }
    let playbackPositionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.playbackPosition", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playbackPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let viewMessageArg = args[0] as! ViewMessage
        do {
          let result = try api.playbackPosition(viewMessage: viewMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playbackPositionChannel.setMessageHandler(nil)
    }
    let qualitiesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.qualities", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      qualitiesChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let viewMessageArg = args[0] as! ViewMessage
        do {
          let result = try api.qualities(viewMessage: viewMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      qualitiesChannel.setMessageHandler(nil)
    }
    let qualityChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.quality", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      qualityChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let qualityMessageArg = args[0] as! FQualityMessage
        do {
          let result = try api.quality(qualityMessage: qualityMessageArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      qualityChannel.setMessageHandler(nil)
    }
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { _, reply in
        do {
          let result = try api.create()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.pause", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let viewMessageArg = args[0] as! ViewMessage
        do {
          try api.pause(viewMessage: viewMessageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let loadChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.load", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      loadChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let loadMessageArg = args[0] as! LoadMessage
        do {
          try api.load(loadMessage: loadMessageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      loadChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.play", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let viewMessageArg = args[0] as! ViewMessage
        do {
          try api.play(viewMessage: viewMessageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let seekToChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.seekTo", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekToChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let seekMessageArg = args[0] as! SeekMessage
        do {
          try api.seekTo(seekMessage: seekMessageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      seekToChannel.setMessageHandler(nil)
    }
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.IvsPlayerApi.dispose", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let viewMessageArg = args[0] as! ViewMessage
        do {
          try api.dispose(viewMessage: viewMessageArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
  }
}
